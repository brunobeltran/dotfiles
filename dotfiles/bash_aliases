# shellcheck shell=bash disable=SC2164

# for sanity
alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Bazel should always secretly be Bazelisk if possible.
alias bazel=bazelisk

# for a beep
alias beep='play -qn synth 1 sine 800 vol 1 '

# Use the mac names for our copy buffer commands. wl-copy is a Wayland
# replacement for xclip (requires the wl-clipboard package).
if [[ -z "$(which pbcopy)" ]]; then
    alias pbcopy='wl-copy'
    alias pbpaste='wl-paste'
fi

# makes all aliases accessible via sudo
alias sudo='sudo '

# Always give me a python that makes sense.
_should_alias_python_to_python3=false
if [[ -z "$(which python)" && -n "$(which python3)" ]]; then
    _should_alias_python_to_python3=true
fi
if [[ -x "$(command -v lsb_release)" ]] && ! lsb_release -a | grep -q Debian; then
    _should_alias_python_to_python3=true
fi
if [[ "$_should_alias_python_to_python3" = true ]]; then
    if [[ -z "$(ls ~/.miniconda*)" ]]; then
        alias python='python3'
        if [[ -n "$(which pip3)" ]]; then
            alias pip='pip3'
        fi
    fi
fi
unset _should_alias_python_to_python3

WORKTREE_ROOT="${HOME}/developer/dbSDK"
if [[ ! -d "${WORKTREE_ROOT}" ]]; then
    # Try one alternative directory just in case.
    WORKTREE_ROOT="${HOME}/dbSDK"
fi

# Instantiate Git worktree aliases for Digital Biology only if the WORKTREE_ROOT
# exists.
if [[ -d "${WORKTREE_ROOT}" ]]; then
    gtw() {
        cd "${WORKTREE_ROOT}"
        ls
    }
    hgd() {
        local worktree_path
        worktree_path="${WORKTREE_ROOT}/$1"
        if [[ -d "${worktree_path}" ]]; then
            echo "Worktree exists, taking you there!"
            cd "${worktree_path}"
            pwd
        else
            if git show-ref --verify --quiet "refs/heads/$1"; then
                echo "Checking out existing branch...$1"
                git worktree add "${worktree_path}" "$1" && cd "${worktree_path}"
            else
                git worktree add "${WORKTREE_ROOT}/$1" main -b "$1" && cd "${worktree_path}"
            fi
        fi
    }
    _exists_pr() {
        [[ "$#" -eq 2 ]] || return 255
        gh pr list --search "is:pr $2 head:$1" --json headRefName |
            python -c 'import sys, json; [print(o["headRefName"]) for o in json.load(sys.stdin)]' |
            grep -q "^$1$"
        return $?
    }
    hgdelete() {
        local worktree_path
        worktree_path="${WORKTREE_ROOT}/$1"
        if [[ "$2" != "-f" ]]; then
            local failed=false
            if _exists_pr "$1" "is:open"; then
                failed=true
                echo "ERROR: Found open PR with 'gh pr list --search \"is:pr is:open head:$1\"'"
            fi
            if ! _exists_pr "$1" "is:closed"; then
                failed=true
                echo "ERROR: Closed PR not found with 'gh pr list --search \"is:pr is:closed head:$1\"'"
            fi
            if [[ "$failed" = true ]]; then
                echo "Pass \"-f\" flag to ignore this and still attempt removal."
                echo "WARNING: \"-f\" flag FORCES worktree and local branch+remote deletion!"
                return 1
            fi
        fi
        if [[ -d "${worktree_path}" ]]; then
            echo -n "Attempting to remove git worktree at ${worktree_path}..."
            if ! git worktree remove "$2" "${worktree_path}" &&
                echo "Success!" ||
                echo "FAILED. Pass '-f' to force."; then
                return 2
            fi
        fi
        [[ "$2" == "-f" ]] && d_flag="-D" || d_flag="-d"
        echo -n "Attempting to force-delete local branch with 'git branch $d_flag $1'..."
        if ! git branch "$d_flag" "$1"; then
            echo "FAILED. Pass '-f' to upgrade to use 'git branch -D'."
            return 3
        else
            echo "Success!"
        fi
        echo -n "Attempting to delete corresponding upstream branch: origin/$1..."
        if ! git push -d origin "$1"; then
            return 4
        fi
        echo "Successfully scrubbed all references to $1"
    }
fi
